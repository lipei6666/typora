## 一、设备号

### 1.申请设备号

```c
int register_chrdev_region(dev_t devno,unsigned count,const char *name);
```

功能：手动分配设备号，如果该设备号没有被占用，则申请该设备号

参数：

**devno**---自己指定的设备号

**count**---申请的设备数量

**name**---在/proc/devices文件中与该设备对应的name

返回值：成功返回0，失败返回错误码



```c
int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name);
```

功能：动态分配设备号

参数：

**dev**---分配成功后的设备号保存地址

**baseminor**---起始的次设备号，一般为0

**count**---申请设备数量

**name**---在/proc/devices文件中与该设备对应的name



### 2.注销设备号

```c
void unregister_chrdev_region(dev_t dev,unsigned count);
```

功能：释放设备号

参数：

**dev**---已成功分配的设备号

**count**---设备数量



> 释放后在/proc/devices文件中对应的记录消失



## 二、字符设备

### 1.申请字符设备

#### 1.1初始化结构体

```c
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
```



#### 1.2.向内核添加字符设备

```c
int cdev_add(struct cdev *p, dev_t dev, unsigned count);
```

参数说明：

p---cdev结构体指针

dev---设备号

count---申请设备数量



### 2.注销字符设备

```c
void cdev_del(struct cdev *p);
```



## 三、相关结构体

### 1.struct cdev

```c
struct cdev
{
	struct kobject kobj;//表示该类型实体是一种内核对象
	struct module *owner;//填THIS_MODULE，表示该字符设备从属于哪个内核模块
	const struct file_operations *ops;//指向空间存放着针对该设备的各种操作函数地址
	struct list_head list;//链表指针域
	dev_t dev;//设备号
	unsigned int count;//设备数量
};
```



### 2.struct file_operations

```c
struct file_operations 
{
   struct module *owner;  //填THIS_MODULE，表示该结构体对象从属于哪个内核模块
   int (*open) (struct inode *, struct file *);	//打开设备
   int (*release) (struct inode *, struct file *);	//关闭设备
   ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);	//读设备
   ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);    //写设备
   loff_t (*llseek) (struct file *, loff_t, int);		//定位
   long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);//读写设备参数，读设备状态、控制设备
   unsigned int (*poll) (struct file *, struct poll_table_struct *);	//POLL机制，实现多路复用的支持
   int (*mmap) (struct file *, struct vm_area_struct *); //映射内核空间到用户层
   int (*fasync) (int, struct file *, int); //信号驱动
   //......
};
```



### 3.struct inode

```c
struct inode
{
	//....
	dev_t  i_rdev;//设备号
	struct cdev  *i_cdev;//如果是字符设备才有此成员，指向对应设备驱动程序中的加入系统的struct cdev对象
	//....
}
```



### 4.struct file

```c
struct file
{
	//...
	mode_t f_mode;//不同用户的操作权限，驱动一般不用
	loff_t f_pos;//position 数据位置指示器，需要控制数据开始读写位置的设备有用
	unsigned int f_flags;//open时的第二个参数flags存放在此，驱动中常用
	struct file_operations *f_op;//open时从struct inode中i_cdev的对应成员获得地址，驱动开发中用来协助理解工作原理，内核中使用
	void *private_data;//本次打开文件的私有数据，驱动中常来在几个操作函数间传递共用数据
	struct dentry *f_dentry;//驱动中一般不用，除非需要访问对应文件的inode，用法flip->f_dentry->d_inode
    int refcnt;//引用计数，保存着该对象地址的位置个数，close时发现refcnt为0才会销毁该struct file对象
	//...
};
```



## 四、操作函数

```c
int (*open) (struct inode *, struct file *);	//打开设备

int (*release) (struct inode *, struct file *);	//关闭设备

ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);	//读设备

ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);    //写设备

loff_t (*llseek) (struct file *, loff_t, int);		//数据操作位置的定位

long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);//读写设备参数，读设备状态、控制设备

unsigned int (*poll) (struct file *, struct poll_table_struct *);//POLL机制，实现对设备的多路复用方式的访问
  
int (*fasync) (int, struct file *, int); //信号驱动
```



## 五、自动创建设备节点

### 1.创建类

```c
struct class *class_create (struct module *owner, const char *name);
```

参数说明：

**owner**：THIS_MODULE

**name**：设备名字



### 2.删除类

```c
void class_destroy(struct class *cls);
```



### 3.创建设备

```c
struct device *device_create(struct class *class,struct device *parent,dev_t devt,void *drvdata,const char *fmt, ...);
```

参数说明：

**class**：类指针

**parent**：父类设备，没有填NULL

**devt**：设备号

**drvdata**：设备可能会使用的一些数据，一般为 NULL  

**fmt**：设备名字



### 4.删除设备

```c
void device_destroy(struct class *class, dev_t devt)
```

