# 6.ARM体系结构


一、计算机三级存储结构
---
三级存储结构：cache(高级缓存)、主存储器(内存)、辅助存储器(硬盘)

CPU能够**直接**读写cache和内存

地址空间：一个处理器能够访问(读写)的存储空间是有限的，我们称这个空间为地址空间(寻址空间)。
一般来说N位地址总线的处理器的地址空间是2的N次方

例如：32位的cpu能够访问的地址空间为2的32次方 大约4G大小

----------

二、ARM基础知识
---
1.ARM系列处理器分类
* Cortex-A系列：针对开放式操作系统的高性能处理器，应用于只能手机、数字电视，笔记本等高端运用
* Cortex-R系列：针对实时性系统、满足实时性的控制需求，应用于汽车制动系统，动力系统等
* Cortex-M系列：为单片机驱动提供方案，应用于微控制器、传感器等

RISC处理器：只保留常用的简单的指令，硬件结构简单，复杂操作通过简单指令组合实现，功耗体积小。

SOC：片上系统，将一个系统所需要的全部部件集成在一个芯片中

2.指令集

**指令**：能够指示处理器执行某种运算的命令成为指令，指令在内存中以**二进制**方式存在，<mark>每一条指令都对应一条汇编</mark>，程序是指令的**有序**集合

指令集：处理器能够识别的指令的集合称为指令集，不同架构的处理器指令集不同，指令集是处理器对开发者提供的接口


3.编译原理

gcc编译四步：
①预处理：插入#include<文件> ，#define替换等
②编译：生成汇编代码
③汇编：生成二进制文件
④链接：将目标文件与库文件（静态库或动态库）链接得到可执行文件

> 指令与汇编一一对应，不可移植


4.ARM数据类型

ARM采用32位架构，基本数据类型有三种：
* byte---8bit
* halfword---16bit
* word---32bit

数据存储：
word型数据在内存的起始地址必须是4的整数倍
halfword型数据在内存的起始地址必须是2的整数倍

5.寄存器

寄存器是处理器内部的存储器，没有地址
寄存器一般用于暂时存放参与运算的数据和运算结果

分类：通用寄存器、专用寄存器、控制寄存器

专用寄存器：
R15(PC)：程序计数器，用于存储当前取址指令的地址
R14(LR)：链接寄存器，执行**跳转指令**或**异常**时，LR会自动保存跳转指令下一条指令的地址，程序需要返回时将LR值赋给PC
R12(SP)：栈指针，用于存储当前模式下的栈顶地址

CRSR寄存器：当前状态寄存器

6.异常

ARM异常响应动作(CPU自动执行)
* 拷贝CPSR中的内容到对应异常模式下的SPSR寄存器
* 修改CPSR的值：禁止相应中断(保证同优先级异常不对被打断)、修改模式为对应异常模式、修改为ARM状态
* 保存返回地址到对应异常模式下的LR
* 设置PC为相应的异常向量

异常向量表：本质为那内存中的一段代码，表中为每个异常分哦欸了四个字节存储空间，遇到异常后处理器自动将PC修改为对应的地址

在异常向量表对应位置写一条跳转指令到异常处理程序入口即可实现跳转


异常返回(需要自己编写)
* 将SPSR的值赋给CPSR，恢复处理器之前状态
* 将LR的值赋给PC，使程序跳转回之前代码继续运行

FIQ比IRQ快的原因：
* FIQ在异常向量表末尾，可直接把异常处理写在向量表后，省去跳转
* FIQ模式有5个私有寄存器(R8---R12)，中断处理程序前无需压栈保存寄存器
* FIQ优先级高于IRQ，可以打断IRQ


----------

三、汇编
---
汇编中的符号分为三类：指令、伪指令、伪操作

1.指令：
能够编译生成一条32位的机器码，且能被CPU识别和执行

* 数据处理指令：		数学运算、逻辑运算

①数据搬移指令
```c
MOV R1, #1     @表示R1=1
MOV R1, R2     @表示R1=R2

MVN R1, #0xFF  @表示R1=~(0xFF)
```
②数据运算
基本格式：操作码(指示执行哪种运算)   目标寄存器(存储运算结果)    第一操作寄存器(第一个参与运算的寄存器数据)   第二操作数(可以是数也可以是寄存器)
```c
@加法指令
ADD R1, R2, R3  @表示R1=R2+R3
ADD R1, R2, #3  @表示R1=R2+3

@减法指令
SUB R1, R2, R3  @表示R1=R2-R3
SUB R1, R2, #3  @表示R1=R2-3

@逆向减法指令
RSB R1, R2, #3  @表示R1=3-R2

@乘法指令(只能两个寄存器相乘)
MUL R1, R2, R3  @表示R1=R2*R3  

@按位与
AND R1, R2, R3  @表示R1=R2&R3

@按位或
ORR R1, R2, R3  @表示R1=R2|R3

@按位异或
EOR R1, R2, R3  @表示R1=R2^R3

@左移
LSL R1, R2, R3  @表示R1=(R2<<R3)

@右移
LSR R1, R2, R3  @表示R1=(R2>>R3)

@位清零
BIC R1, R2, #0x0F  @第二操作数中的哪一位为1，就将第一操作寄存器的中哪一位清零，然后将结果写入目标寄存器
```
----------

* 跳转指令：实现程序的跳转，本质就是修改了PC寄存器

①直接修改寄存器的值(不建议使用)

②不带返回的跳转指令
```c
B   FUNC      @表示跳转到FUNC类似C语言中的goto
```

③带返回的跳转指令
```c
BL FUNC       @LR寄存器会自动保存返回地址
```

④条件码
```c
CMP R1, R2    @CMP指令的本质就是一条减法指令（SUBS），只是没有将运算结果存入目标寄存器
BEQ FUNC      @跳转指令加后缀EQ表示：如果R1==R2则执行跳转
```
----------

* Load/Srore指令：	访问（读写）内存

```c
MOV R1, #0xFF000000
MOV R2, #0x40000000
STR R1, [R2]    @将R1寄存器中的数据写入到R2指向的内存空间

LDR R3, [R2]    @将R2指向的内存空间中的数据读取到R3寄存器

STRB R1, [R2]   @将R1寄存器中的数据的Bit[7:0]写入到R2指向的内存空间   后缀B表示一个字节

STRH R1, [R2]   @将R1寄存器中的数据的Bit[15:0]写入到R2指向的内存空间  后缀H表示两个字节
```

CPU寻址方式

```c
MOV R1, #1
ADD R1, R2, #1  @立即寻址，使用立即数

ADD R1, R2, R3  @寄存器寻址，在寄存器中获取数据

MOV R1, R2, LSL #1  @寄存器移位寻址

STR R1, [R2]    @寄存器间接寻址，在内存中获取

MOV R1, #0xFFFFFFFF
MOV R2, #0x40000000
MOV R3, #4
STR R1, [R2,R3]          @基址加变址寻址，获取内存地址R2+R3中的数据，也称为前索引
STR R1, [R2,R3,LSL #1]   @获取内存地址R2+(R3<<1)
STR R1, [R2],#8          @后索引先将R1寄存器中数写入R2地址，然后R2地址加8
STR R1, [R2,#8]!         @自动索引，将R1寄存器中数写入(R2+8)中，然后R2地址加8
```
----------


* 状态寄存器传送指令：访问（读写）CPSR寄存器

```c
MRS R1, CPSR      @读 R1=CPSR

MSR CPSR, #0x10   @写 CPSR=0x10
```

* 软中断指令：		触发软中断异常

```c
SWI #1  
```

* 协处理器指令：		操控协处理器的指令

----------

2.伪指令：本身不是指令，编译器可以将其替换成若干条等效指令
①空指令
  `NOP`
  
②LDR伪指令
```c
LDR R1, =0x12345678  @LDR伪指令可以将任意一个32位的数据放到一个寄存器
LDR R1, =STOP        @将STOP(标签)表示的地址写入R1寄存器
LDR R1, STOP         @将STOP地址中的内容写入R1寄存器
```

3.伪操作：不会生成代码，只是在编译之前告诉编译器怎么编译，一般以“.”开头
```c
.global symbol     @将symbol声明成全局符号
.local symbol      @将symbol声明成局部符号
.equ DATA, 0xFF    @宏定义，类似于#define
```
----------

4.C和汇编的混合编程

①汇编语言跳转C语言
```c
MOV R1, #1
MOV R2, #2
BL  func_c   @跳转到C语言fun_c()函数
MOV R3, #3
```
②C语言跳转汇编
```c
@汇编代码
.global FUNC_ASM
FUNC_ASM:
MOV R4, #4
MOV R5, #5

FUNC_ASM();    @C语言代码跳转
```
③内嵌
```c
void func_c(void)
{
	int a;
	a ++;
	//C内联（内嵌）汇编
	asm
	(
		"MOV R6, #6\n"
		"MOV R7, #7\n"
	);
	//C语言调用（跳转）汇编语言
	FUNC_ASM();
	a --;
}
```

----------

5.ATPCS协议

* 使用满减栈
* R15用作程序计数器，不能作其他用途
* R14用作链接寄存器，不能作其他用途
* R13用作栈指针，不能作其他用途
* 当函数的参数不多于4个时使用R0-R3传递，当函数的参数多于4个时，多出的部分用栈传递
* 函数的返回值使用R0传递
* 其它寄存器主要用于存储局部变量